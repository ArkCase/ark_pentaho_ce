#!/bin/bash
set -euo pipefail

say() {
	echo -e "$(date -u -Isec): ${@}"
}

fail() {
	say "${@}" 1>&2
	exit ${EXIT_CODE:-1}
}

to_boolean() {
	case "${1,,}" in
		true | t | 1 | yes | on | enabled | enable ) echo "true" ;;
		* ) echo "false" ;;
	esac
}

is_valid_hostname() {
	local NAME="${1,,}"
	[[ "${NAME}" =~ ^([a-z0-9][-a-z0-9]*)?[a-z0-9]([.]([a-z0-9][-a-z0-9]*)?[a-z0-9])*$ ]] || return 1
	return 0
}

is_valid_port() {
	local PORT="${1}"
	[[ "${PORT}" =~ ^(0|[1-9][0-9]*)$ ]] || return 1
	[ ${PORT} -gt 0 ] || return 1
	[ ${PORT} -lt 65536 ] || return 1
	return 0
}

download_authorities() {
	local HOST="${1}"
	local SNI="${2}"
	local PORT="${3}"
	local TARGET="${4}"

	local SNI_FLAGS=()
	[ -n "${SNI}" ] && SNI_FLAGS+=(-servername "${SNI}")

	local CERT_BASE_NAME="${TARGET}/${SNI}"
	[ -n "${SNI}" ] && CERT_BASE_NAME+="@"
	CERT_BASE_NAME+="${HOST}:${PORT}"
	(
		set -euo pipefail
		SPLIT_DIR="$(mktemp -d)"
		cd "${SPLIT_DIR}"
		csplit \
			<(openssl s_client -connect "${HOST}:${PORT}" "${SNI_FLAGS[@]}" -showcerts </dev/null 2>/dev/null) \
			'/BEGIN CERTIFICATE/' '{*}'
		RC=1
		for n in * ; do
			# Leave only the certificate bits in each split out file
			sed -i -e '/^-\+END CERTIFICATE-\+$/q' "${n}"

			# Keep only the files that contain certificate bits
			grep -q "END CERTIFICATE" "${n}" || continue

			# Is the certificate a CA certificate of some kind?
			openssl x509 -noout -ext keyUsage -in "${n}" | \
				tail -n +2 | \
				sed -e 's;, ;\n;g' -e 's;^\s*;;g' | \
				grep -qi "^Certificate Sign" || continue

			# The certificate is desirable ... stow it for trust!
			cp -vf "${n}" "${CERT_BASE_NAME}.${n}.pem"
			RC=0
		done
		[ ${RC} -eq 0 ] || say "\tNone of the candidate certificates were CAs"
		cd /
		rm -rf "${SPLIT_DIR}" &>/dev/null
		exit ${RC}
	)
	return ${?}
}

[ "$(id -u)" -eq 0 ] || exec /usr/bin/sudo --non-interactive --preserve-env "${0}" "${@}"

[ -v BASE_DIR ] || BASE_DIR="/app"
[ -v INIT_DIR ] || INIT_DIR="${BASE_DIR}/init"
[ -v INIT_SSL_DIR ] || INIT_SSL_DIR="${INIT_DIR}/ssl"

INSTALLED="false"

[ -v SSL_TARGET ] || SSL_TARGET="/etc/pki/ca-trust/source"
[ -v ANCHORS ] || ANCHORS="${SSL_TARGET}/anchors"

# Try to get the CA from the LDAP URL. If this fails, it's not critical
[ -v LDAP_URL ] || LDAP_URL="ldaps://ldap"
if [[ "${LDAP_URL}" =~ ^ldap(s)?://([^:/]+)(:[0-9]+)? ]] ; then
	LDAP_HOST="${BASH_REMATCH[2]}"
	LDAP_PORT="${BASH_REMATCH[3]}"
	if [ -z "${LDAP_PORT}" ] ; then
		# No port specified, so use one of the default ports
		LDAP_PORT=389
		[ -n "${BASH_REMATCH[1]}" ] && LDAP_PORT=636
	else
		# The port may contain leading colons and zeroes, so remove them
		LDAP_PORT="$(sed -e 's;^:*;;g' -e 's;^0*;;g' < <(echo -n "${LDAP_PORT}"))"
	fi

	# 1) Try to fetch the actual certificates served up by Step-CA. If this fails,
	# it's non-fatal b/c we do this "blindly" every time to avoid having to add more
	# complex and difficult logic into Helm and other places ... i.e. if the target
	# environment lacks this, this is fine - they'll just have to manage the CAs
	# manually by some other means, and use the INIT_SSL_SERVERS variable to do so
	say "Fetching the Step-CA root certificate from host ${LDAP_HOST}"
	if curl -kL --connect-timeout 5 -o "${ANCHORS}/step-ca.crt" "https://${LDAP_HOST}:9000/roots.pem" 2>&1 ; then
		say "\tFetched the Step-CA root certificate from [${LDAP_HOST}]"
		INSTALLED="true"
	else
		say "\tWARNING: failed to fetch the Step-CA root certificate from [${LDAP_HOST}] (rc=${?})"
	fi

	# 2) Try to see if the LDAP server itself is serving up its CA certificates
	if download_authorities "${LDAP_HOST}" "" "${LDAP_PORT}" "${ANCHORS}" ; then
		INSTALLED="true"
	else
		say "WARNING: Failed to fetch the certificates from host ${LDAP_HOST}, port ${LDAP_PORT}"
	fi
else
	say "LDAP URL [${LDAP_URL}] couldn't be parsed properly, won't try to fetch its certificates"
fi

if [ -d "${INIT_SSL_DIR}" ] ; then
	REPLACE_FLAG=""
	[ -v INIT_SSL_REPLACE ] || INIT_SSL_REPLACE="false"
	"$(to_boolean "${INIT_SSL_REPLACE}")" && REPLACE_FLAG="u"

	say "Deploying the trusted certificates"

	[ -z "${REPLACE_FLAG}" ] || say "WARNING: will replace any existing files during the certificate copy"

	#
	# We use this approach b/c this will only take regular files (no symlinks!!). This
	# is important for security purposes. It will also not clobber existing files - again,
	# for security purposes.
	#
	( cd "${INIT_SSL_DIR}" && /usr/bin/find . -type f | /usr/bin/sort ) |  \
		( cd "${INIT_SSL_DIR}" && /usr/bin/cpio -p${REPLACE_FLAG}madv "${SSL_TARGET}" ) | \
		/usr/bin/sed -e 's;^;\t;g'
	INSTALLED="true"
fi

if [ -v INIT_SSL_SERVERS ] ; then
	# The INIT_SSL_SERVERS variable is a comma-separated list of coordinates
	# in the form [serverName@]serverAddressOrHostname:port, or in the form
	# of http/https URLS, from where SSL CA certificates should be downloaded
	# and added to the trust store
	readarray -d "," -t SERVERS < <(echo -n "${INIT_SSL_SERVERS}")
	for SERVER in "${SERVERS[@]}" ; do
		[ -n "${SERVER}" ] || continue
		say "Downloading additional certificates from ${SERVER} ..."
		if [[ "${SERVER}" =~ ^(([^@]+)@)?(([^:]+):([0-9]+))$ ]] ; then
			SERVER_NAME="${BASH_REMATCH[2]}"
			HOST_NAME="${BASH_REMATCH[4]}"
			PORT="${BASH_REMATCH[5]}"
			if [ -n "${SERVER_NAME}" ] ; then
				is_valid_hostname "${SERVER_NAME}" || fail "\tInvalid server name [${SERVER_NAME}] in spec: [${SERVER}]"
			fi
			is_valid_hostname "${HOST_NAME}" || fail "\tInvalid host name [${HOST_NAME}] in spec: [${SERVER}]"
			is_valid_port "${PORT}" || fail "\tInvalid port number [${PORT}] in spec: [${SERVER}]"
			download_authorities "${HOST_NAME}" "${SERVER_NAME}" "${PORT}" "${ANCHORS}" || fail "\tFailed to download the certificate from [${SERVER}]"
		elif [[ "${SERVER}" =~ ^https?://.*$ ]] ; then
			# It's an HTTP URL, so fetch it from there
			read SUM rest < <(echo -n "${SERVER}" | md5sum)
			/usr/bin/curl -kL -o "${ANCHORS}/downloaded-${SUM}.crt" "${SERVER}" || fail "\tFailed to download the certificate from [${SERVER}]"
		else
			fail "\tInvalid certificate server spec: [${SERVER}]"
		fi
		INSTALLED="true"
	done
fi

if ! "${INSTALLED}" ; then
	say "No certificates to be installed"
	exit 0
fi

say "Updating the trusted certificates"
/usr/bin/chown -R root:root "${SSL_TARGET}"
/usr/bin/chmod -R 0440 "${SSL_TARGET}"
exec /usr/bin/update-ca-trust extract
